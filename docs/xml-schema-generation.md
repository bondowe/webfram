# XML Schema Generation

The `GenerateXMLSchema` function generates OpenAPI 3.2.0 compliant XML schemas from Go types, respecting custom `xml` struct tags to properly represent the XML structure in the OpenAPI specification.

## Overview

Unlike `GenerateJSONSchema` which generates schemas for JSON serialization, `GenerateXMLSchema` specifically handles XML serialization and includes XML metadata in the generated OpenAPI schemas. This ensures that the OpenAPI specification accurately reflects how XML documents will be structured when your API serializes or deserializes XML data.

## Key Features

1. **XML Tag Support**: Respects Go's `xml` struct tags to determine element vs attribute serialization
2. **Nested Structures**: Properly handles nested structs with XML references
3. **Array Handling**: Correctly represents XML array serialization with proper element naming
4. **Automatic Examples**: Generates realistic mock data examples for all XML schemas
5. **Slice Wrapping**: Properly wraps slice examples with xmlRootName for valid XML structure
6. **Validation Preservation**: Maintains all validation rules from `validate` tags
7. **Type Safety**: Supports all Go primitive types, time.Time, uuid.UUID, and custom types
8. **OpenAPI 3.2.0 Compliance**: Follows the XML Object specification from OpenAPI 3.2.0

## XML Object Properties

According to OpenAPI 3.2.0, the XML Object includes the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `nodeType` | string | One of `element`, `attribute`, `text`, `cdata`, or `none`. Default is `element`. |
| `name` | string | Sets the name of the element/attribute, replacing the inferred name. |
| `namespace` | string | The IRI of the namespace definition (must be a non-relative IRI). |
| `prefix` | string | The prefix to be used for the name. |

## Usage

```go
import (
    "github.com/bondowe/webfram/internal/bind"
    "github.com/bondowe/webfram/openapi"
)

// Define your type with xml tags
type Person struct {
    ID    uuid.UUID `xml:"id,attr"`      // XML attribute
    Name  string    `xml:"name"`          // XML element (default)
    Email string    `xml:"email,attr"`    // XML attribute
    Age   int       `xml:"age"`           // XML element
}

// Generate XML schema
components := &openapi.Components{}
var person Person
schema := bind.GenerateXMLSchema(person, components)

// Use in OpenAPI specification
response := openapi.Response{
    Content: map[string]openapi.MediaType{
        "application/xml": {
            Schema: schema,
        },
    },
}
```

## XML Tag Syntax

### Basic Tags

```go
type Example struct {
    // Creates XML element: <field>value</field>
    Field string `xml:"field"`
    
    // Creates XML attribute: <Example attr="value">
    Attr string `xml:"attr,attr"`
    
    // Field is ignored in XML serialization
    Ignored string `xml:"-"`
}
```

### Array Tags

```go
type Book struct {
    // Each author becomes: <author>Name</author>
    Authors []string `xml:"author"`
    
    // Each rating becomes: <rating>5</rating>
    Ratings []int `xml:"rating"`
}
```

Result:

```xml
<Book>
    <author>Author 1</author>
    <author>Author 2</author>
    <rating>5</rating>
    <rating>4</rating>
</Book>
```

### Nested Structures

```go
type Company struct {
    Name    string  `xml:"name,attr"`
    Address Address `xml:"address"`
}

type Address struct {
    Street string `xml:"street"`
    City   string `xml:"city"`
}
```

Result:

```xml
<Company name="ACME Corp">
    <address>
        <street>123 Main St</street>
        <city>Springfield</city>
    </address>
</Company>
```

## Generated Schema Structure

The `GenerateXMLSchema` function generates schemas with the following characteristics:

### 1. XML Metadata

Each property includes XML metadata:

```json
{
  "properties": {
    "id": {
      "type": "string",
      "format": "uuid",
      "xml": {
        "nodeType": "attribute",
        "name": "id"
      }
    },
    "name": {
      "type": "string",
      "xml": {
        "nodeType": "element",
        "name": "name"
      }
    }
  }
}
```

### 2. Nested References

Nested structs are registered as reusable components:

```json
{
  "properties": {
    "address": {
      "$ref": "#/components/schemas/main.Address"
    }
  }
}
```

### 3. Array Items

Array items include XML metadata for each element:

```json
{
  "properties": {
    "tags": {
      "type": "array",
      "xml": {
        "nodeType": "element",
        "name": "tag"
      },
      "items": {
        "type": "string",
        "xml": {
          "nodeType": "element",
          "name": "tag"
        }
      }
    }
  }
}
```

## Automatic Example Generation

XML schemas generated by `GenerateXMLSchema` now automatically include realistic example data. This helps API consumers understand the expected XML structure and data formats.

### Features

- **Mock Data Generation**: Automatically generates appropriate mock values for all supported types
- **Slice Wrapping**: Slice examples are properly wrapped with the `xmlRootName` for valid XML structure
- **Type-Aware Values**: Generates realistic data based on field types (UUIDs, timestamps, strings, numbers, etc.)
- **Nested Structure Support**: Examples include mock data for nested structs and arrays

### Example Generation

```go
type User struct {
    ID    uuid.UUID `xml:"id,attr"`
    Name  string    `xml:"name"`
    Email string    `xml:"email,attr"`
    Age   int       `xml:"age"`
}

components := &openapi.Components{}
var user User

// Generate schema with automatic example
schema := bind.GenerateXMLSchema(user, components)

// The schema now includes an example field with mock XML data
```

Generated schema includes:

```json
{
  "type": "object",
  "properties": { ... },
  "example": "<User id=\"550e8400-e29b-41d4-a716-446655440000\" email=\"example\"><name>example</name><age>42</age></User>"
}
```

### Slice Examples with Root Wrapping

For slice types, examples are automatically wrapped with the provided `xmlRootName`:

```go
var users []User
schema := bind.GenerateXMLSchema(users, "users", components)

// Example is properly wrapped:
"<users><User id=\"550e8400-e29b-41d4-a716-446655440000\" email=\"example\"><name>example</name><age>42</age></User><User id=\"550e8400-e29b-41d4-a716-446655440001\" email=\"example\"><name>example</name><age>42</age></User></users>"
```

### Supported Mock Data Types

| Type | Example Value |
|------|---------------|
| `string` | `"example"` |
| `int`, `int8`, `int16`, `int32`, `int64` | `42` |
| `uint`, `uint8`, `uint16`, `uint32`, `uint64` | `42` |
| `float32`, `float64` | `3.14` |
| `bool` | `true` |
| `uuid.UUID` | `"550e8400-e29b-41d4-a716-446655440000"` |
| `time.Time` | `"2024-01-15T10:30:00Z"` |
| Arrays/Slices | Multiple mock items |
| Structs | Mock data for all fields |

## Complete Example

```go
package main

import (
    "time"
    "github.com/bondowe/webfram/internal/bind"
    "github.com/bondowe/webfram/openapi"
    "github.com/google/uuid"
)

// Person with various XML serialization patterns
type Person struct {
    ID        uuid.UUID `xml:"id,attr" validate:"required"`
    Name      string    `xml:"name" validate:"required,minlength=2"`
    Email     string    `xml:"email,attr" validate:"required,format=email"`
    Age       int       `xml:"age" validate:"min=0,max=120"`
    Active    bool      `xml:"active"`
    CreatedAt time.Time `xml:"created_at"`
    Address   Address   `xml:"address"`
    Tags      []string  `xml:"tag"`
}

type Address struct {
    Country string `xml:"country,attr"`
    Street  string `xml:"street"`
    City    string `xml:"city"`
    ZipCode string `xml:"zip,attr"`
}

func main() {
    components := &openapi.Components{}
    var person Person
    
    // Generate XML schema
    schema := bind.GenerateXMLSchema(person, components)
    
    // Schema will be available at: #/components/schemas/main.Person
    // With proper XML metadata for all fields
}
```

### Generated XML Example

```xml
<Person id="550e8400-e29b-41d4-a716-446655440000" email="john@example.com">
  <name>John Doe</name>
  <age>30</age>
  <active>true</active>
  <created_at>2024-01-15T10:30:00Z</created_at>
  <address country="USA" zip="12345">
    <street>123 Main St</street>
    <city>Springfield</city>
  </address>
  <tag>developer</tag>
  <tag>golang</tag>
</Person>
```

## Serializing Arrays with XMLArray

The standard `XML()` method uses Go's `encoding/xml` package, which doesn't automatically wrap slices in a root element. This creates invalid XML when serializing arrays directly.

### The Problem

```go
users := []User{{Name: "Alice"}, {Name: "Bob"}}
w.XML(users)  // Invalid: No root element!
// Produces: <User><Name>Alice</Name></User><User><Name>Bob</Name></User>
```

### Solution 1: Use XMLArray (Recommended)

The `XMLArray` method automatically wraps your slice with a root element:

```go
users := []User{
    {ID: 1, Name: "Alice", Email: "alice@example.com"},
    {ID: 2, Name: "Bob", Email: "bob@example.com"},
}

// Wrap with <users> root element
w.XMLArray(users, "users")
```

Result:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<users>
  <User id="1">
    <Name>Alice</Name>
    <Email>alice@example.com</Email>
  </User>
  <User id="2">
    <Name>Bob</Name>
    <Email>bob@example.com</Email>
  </User>
</users>
```

### XMLArray Method Signature

```go
func (w *ResponseWriter) XMLArray(items any, rootName string) error
```

**Parameters:**

- `items`: Must be a slice (any element type)
- `rootName`: The wrapping element name (e.g., "users", "products")

**Features:**

- Automatically adds XML declaration (`<?xml version="1.0"?>`)
- Creates valid XML with proper root element
- Each item uses its struct's `XMLName` or type name for element naming
- Works with any slice type (structs, primitives, etc.)
- Sets `Content-Type: application/xml` header

### Solution 2: Wrap in a Struct

Alternatively, create a wrapper struct:

```go
type UsersResponse struct {
    XMLName xml.Name `xml:"users"`
    Users   []User   `xml:"user"`
}

response := UsersResponse{Users: users}
w.XML(response)
```

Result:

```xml
<users>
  <user id="1"><Name>Alice</Name><Email>alice@example.com</Email></user>
  <user id="2"><Name>Bob</Name><Email>bob@example.com</Email></user>
</users>
```

## Integration with OpenAPI

Use `GenerateXMLSchema` when defining API endpoints that return XML:

```go
mux.HandleFunc("GET /users/xml", func(w app.ResponseWriter, r *app.Request) {
    users := []User{
        {ID: uuid.New(), Name: "John", Email: "john@example.com"},
    }
    
    // Use XMLArray for valid XML output with proper wrapping
    w.XMLArray(users, "users")
}).WithOperationConfig(&app.OperationConfig{
    Responses: map[string]app.Response{
        "200": {
            Description: "List of users in XML format",
            Content: map[string]app.TypeInfo{
                "application/xml": {TypeHint: &[]User{}},
            },
        },
    },
})
```

The framework will automatically use `GenerateXMLSchema` for `application/xml` media types.

## Differences from GenerateJSONSchema

| Feature | GenerateJSONSchema | GenerateXMLSchema |
|---------|-------------------|-------------------|
| Property Names | Uses `json` tag | Uses `xml` tag |
| Metadata | No XML metadata | Includes XML Object metadata |
| Attributes | Not applicable | Supports `attr` directive |
| Arrays | Simple items | XML element naming for each item |
| Default Behavior | Properties as object fields | Properties as XML elements |

## Best Practices

1. **Consistent Naming**: Use the same name in both `json` and `xml` tags when possible
2. **Attributes for IDs**: Use attributes for identifiers and metadata
3. **Elements for Content**: Use elements for primary content and nested structures
4. **Array Naming**: Use singular names for array item elements
5. **Validation**: Always include validation tags - they're preserved in both schemas

## Testing

Comprehensive tests for XML schema generation are available in `internal/bind/schema_test.go`:

- `TestGenerateXMLSchema_BasicTypes`: Tests all primitive types and their XML representation
- `TestGenerateXMLSchema_Arrays`: Tests array handling with proper XML element naming
- `TestGenerateXMLSchema_NestedStructs`: Tests nested structure handling and references
- `TestGenerateXMLSchema_UnsignedIntegers`: Tests unsigned integer types with correct formats
- `TestGenerateXMLSchema_SliceExamples`: Tests automatic example generation with proper slice wrapping

## See Also

- [OpenAPI 3.2.0 XML Object Specification](https://spec.openapis.org/oas/v3.2.0.html#xml-object)
- [Go xml Package Documentation](https://pkg.go.dev/encoding/xml)
- [GenerateJSONSchema Documentation](./json-schema-generation.md)
